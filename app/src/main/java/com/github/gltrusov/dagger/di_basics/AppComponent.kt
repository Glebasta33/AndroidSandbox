package com.github.gltrusov.dagger.di_basics

import com.github.gltrusov.MainActivity
import dagger.Component
import dagger.Module
import dagger.Provides


/**
 * # Курс по Dagger 2 - Android Broadcast.
 * ## 1. Основы DI и Dagger
 * Inversion of Control (IoC, инверсия управления) - принцип, согласно которому компоненты системы
 * должны быть как можно меньше связаны с другими компонентами, не полагаясь в своей работе на детали конкретной реализации других компонентов.
 *
 * Реализации принципа:
 * * Шаблон "Фабрика" (Factory)
 * * Локатор служб (Service Locator)
 * * DI
 *
 * Dependency Injectioin (DI, внедрение зависимостей) - это реализация принципа IoC, паттерн, при котором
 * зависимости (поля объекта) поставляются внутрь объекта внешней сущностью (Component). Объект не создаёт сам свои зависимости.
 *
 * ## Dagger 2
 *
 *
 * Dagger - это не только сама библиотека (dependency), но и процессор аннотаций, поэтому при подключении
 * библиотеку нужно также включить специальное расширение для компилятора (плагин 'kotlin-kapt').
 *
 * Dagger работает на основе __APT__ (Java Annotation Processing Tool). Данная технология позволят
 * анализировать код, помеченный специальными аннотациями, и генерировать на его основе новый код.
 * Не может модифицировать существующий код, а только создавать новый. При любом изменении
 * аннотируемого кода, необходимо выполнить повторную компиляцию.
 *
 * Компонент (граф зависимостей) - это сущность, которая поставляет зависимоти для классов.
 * Зависимости в компонент передаются через модули (modules).
 * Граф зависимостей - это набор всех объектов-зависимостей и связей между ними.
 */
@Component(
    modules = [AppModule::class]
)
interface AppComponent {

    /**
     * После подключения модуля к компоненту внутри компонента можно получить любой объект зависимости.
     * Можно создать свойство или метод, который возвращает тип нужного объекта.
     *
     * Далее, чтобы получить объект, необходимо сгенерировать граф (Component). Dagger генерирует реализацию интерфейса
     * компонента с приставкой Dagger (DaggerAppComponent).
     * Чтобы получить экземпляр графа нужно вызвать DaggerAppComponent.create()
     *
     * Но таким образом это будет уже не  DI, так как активность сама будет получать зависимость (это скорее Service Locator).
     */
    val computer: Computer

    /**
     * DI - это поставление зависимостей внешней сущностью-компонентом.
     * Даггер генерит реализацию метода, в которой из графа зависимостей в MainActivity
     * внедряются все объекты, нужные для инициализации помеченых аннотацией @Inject полей.
     *
     * Тип параметра функции определяет в какие объекты компонент может внедрить зависимости.
     */
    fun inject(activity: MainActivity)
}

/**
 * Модулем может быть объект или класс.
 * В модуле можно объявлять зависимости, определять каким образом они поставляются.
 */
@Module
object AppModule {

    /**
     * Поставка зависимосте в граф из модуля осуществляется через метод с типом
     * возвращаемого значения, который соответсвует типу зависимости.
     * Чтобы функция поставляла зависимость в граф, необходимо её поментить аннотацией @Provides
     * Если указать зависимости, необходимые для создания объекта зависимости, граф будет их поставлять в метод.
     * Но предворительно их тоже нужно поставить в граф.
     */
    @Provides
    fun provideComputer(
        processor: Processor,
        ram: RAM,
        motherboard: Motherboard
    ): Computer {
        return Computer(processor, motherboard, ram)
    }

    @Provides
    fun provideProcessor(): Processor {
        return Processor()
    }

    @Provides
    fun provideRam(): RAM {
        return RAM()
    }

    @Provides
    fun provideMotherboard(): Motherboard {
        return Motherboard()
    }
}